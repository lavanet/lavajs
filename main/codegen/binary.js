"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WireType = exports.BinaryWriter = exports.BinaryReader = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _utf = require("./utf8");
var _varint = require("./varint");
/**
* This file and any referenced files were automatically generated by @cosmology/telescope@0.104.0
* DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
* and run the transpile command or yarn proto command to regenerate this bundle.
*/
// Copyright (c) 2016, Daniel Wirtz  All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// * Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the distribution.
// * Neither the name of its author, nor the names of its contributors
//   may be used to endorse or promote products derived from this software
//   without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ---
// Code generated by the command line utilities is owned by the owner
// of the input file used when generating it. This code is not
// standalone and requires a support library to be linked with it. This
// support library is itself covered by the above license.
var WireType = /*#__PURE__*/function (WireType) {
  WireType[WireType["Varint"] = 0] = "Varint";
  WireType[WireType["Fixed64"] = 1] = "Fixed64";
  WireType[WireType["Bytes"] = 2] = "Bytes";
  WireType[WireType["Fixed32"] = 5] = "Fixed32";
  return WireType;
}({}); // Reader
exports.WireType = WireType;
var BinaryReader = /*#__PURE__*/function () {
  function BinaryReader(buf) {
    (0, _classCallCheck2["default"])(this, BinaryReader);
    (0, _defineProperty2["default"])(this, "buf", void 0);
    (0, _defineProperty2["default"])(this, "pos", void 0);
    (0, _defineProperty2["default"])(this, "type", void 0);
    (0, _defineProperty2["default"])(this, "len", void 0);
    this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);
    this.pos = 0;
    this.type = 0;
    this.len = this.buf.length;
  }
  (0, _createClass2["default"])(BinaryReader, [{
    key: "assertBounds",
    value: function assertBounds() {
      if (this.pos > this.len) throw new RangeError("premature EOF");
    }
  }, {
    key: "tag",
    value: function tag() {
      var tag = this.uint32(),
        fieldNo = tag >>> 3,
        wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType, tag];
    }
  }, {
    key: "skip",
    value: function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len) throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    }
  }, {
    key: "skipType",
    value: function skipType(wireType) {
      switch (wireType) {
        case WireType.Varint:
          this.skip();
          break;
        case WireType.Fixed64:
          this.skip(8);
          break;
        case WireType.Bytes:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case WireType.Fixed32:
          this.skip(4);
          break;

        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    }
  }, {
    key: "uint32",
    value: function uint32() {
      return _varint.varint32read.bind(this)();
    }
  }, {
    key: "int32",
    value: function int32() {
      return this.uint32() | 0;
    }
  }, {
    key: "sint32",
    value: function sint32() {
      var num = this.uint32();
      return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    }
  }, {
    key: "fixed32",
    value: function fixed32() {
      var val = (0, _varint.readUInt32)(this.buf, this.pos);
      this.pos += 4;
      return val;
    }
  }, {
    key: "sfixed32",
    value: function sfixed32() {
      var val = (0, _varint.readInt32)(this.buf, this.pos);
      this.pos += 4;
      return val;
    }
  }, {
    key: "int64",
    value: function int64() {
      var _varint64read$bind = _varint.varint64read.bind(this)(),
        _varint64read$bind2 = (0, _slicedToArray2["default"])(_varint64read$bind, 2),
        lo = _varint64read$bind2[0],
        hi = _varint64read$bind2[1];
      return BigInt((0, _varint.int64ToString)(lo, hi));
    }
  }, {
    key: "uint64",
    value: function uint64() {
      var _varint64read$bind3 = _varint.varint64read.bind(this)(),
        _varint64read$bind4 = (0, _slicedToArray2["default"])(_varint64read$bind3, 2),
        lo = _varint64read$bind4[0],
        hi = _varint64read$bind4[1];
      return BigInt((0, _varint.uInt64ToString)(lo, hi));
    }
  }, {
    key: "sint64",
    value: function sint64() {
      var _varint64read$bind5 = _varint.varint64read.bind(this)(),
        _varint64read$bind6 = (0, _slicedToArray2["default"])(_varint64read$bind5, 2),
        lo = _varint64read$bind6[0],
        hi = _varint64read$bind6[1];
      // zig zag
      var _zzDecode = (0, _varint.zzDecode)(lo, hi);
      var _zzDecode2 = (0, _slicedToArray2["default"])(_zzDecode, 2);
      lo = _zzDecode2[0];
      hi = _zzDecode2[1];
      return BigInt((0, _varint.int64ToString)(lo, hi));
    }
  }, {
    key: "fixed64",
    value: function fixed64() {
      var lo = this.sfixed32();
      var hi = this.sfixed32();
      return BigInt((0, _varint.uInt64ToString)(lo, hi));
    }
  }, {
    key: "sfixed64",
    value: function sfixed64() {
      var lo = this.sfixed32();
      var hi = this.sfixed32();
      return BigInt((0, _varint.int64ToString)(lo, hi));
    }
  }, {
    key: "float",
    value: function float() {
      throw new Error("float not supported");
    }
  }, {
    key: "double",
    value: function double() {
      throw new Error("double not supported");
    }
  }, {
    key: "bool",
    value: function bool() {
      var _varint64read$bind7 = _varint.varint64read.bind(this)(),
        _varint64read$bind8 = (0, _slicedToArray2["default"])(_varint64read$bind7, 2),
        lo = _varint64read$bind8[0],
        hi = _varint64read$bind8[1];
      return lo !== 0 || hi !== 0;
    }
  }, {
    key: "bytes",
    value: function bytes() {
      var len = this.uint32(),
        start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
  }, {
    key: "string",
    value: function string() {
      var bytes = this.bytes();
      return (0, _utf.utf8Read)(bytes, 0, bytes.length);
    }
  }]);
  return BinaryReader;
}(); // Writer
exports.BinaryReader = BinaryReader;
var Op = /*#__PURE__*/(0, _createClass2["default"])(function Op(fn, len, val) {
  (0, _classCallCheck2["default"])(this, Op);
  (0, _defineProperty2["default"])(this, "fn", void 0);
  (0, _defineProperty2["default"])(this, "len", void 0);
  (0, _defineProperty2["default"])(this, "val", void 0);
  (0, _defineProperty2["default"])(this, "next", void 0);
  this.fn = fn;
  this.len = len;
  this.val = val;
});
var State = /*#__PURE__*/(0, _createClass2["default"])(function State(writer) {
  (0, _classCallCheck2["default"])(this, State);
  (0, _defineProperty2["default"])(this, "head", void 0);
  (0, _defineProperty2["default"])(this, "tail", void 0);
  (0, _defineProperty2["default"])(this, "len", void 0);
  (0, _defineProperty2["default"])(this, "next", void 0);
  this.head = writer.head;
  this.tail = writer.tail;
  this.len = writer.len;
  this.next = writer.states;
});
var BinaryWriter = /*#__PURE__*/function () {
  function BinaryWriter() {
    (0, _classCallCheck2["default"])(this, BinaryWriter);
    (0, _defineProperty2["default"])(this, "len", 0);
    (0, _defineProperty2["default"])(this, "head", void 0);
    (0, _defineProperty2["default"])(this, "tail", void 0);
    (0, _defineProperty2["default"])(this, "states", void 0);
    // uint64 is the same with int64
    (0, _defineProperty2["default"])(this, "uint64", BinaryWriter.prototype.int64);
    // sfixed64 is the same with fixed64
    (0, _defineProperty2["default"])(this, "sfixed64", BinaryWriter.prototype.fixed64);
    // sfixed32 is the same with fixed32
    (0, _defineProperty2["default"])(this, "sfixed32", BinaryWriter.prototype.fixed32);
    this.head = new Op(null, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  (0, _createClass2["default"])(BinaryWriter, [{
    key: "_push",
    value: function _push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }
  }, {
    key: "finish",
    value: function finish() {
      var head = this.head.next,
        pos = 0;
      var buf = BinaryWriter.alloc(this.len);
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }
  }, {
    key: "fork",
    value: function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(null, 0, 0);
      this.len = 0;
      return this;
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(null, 0, 0);
        this.len = 0;
      }
      return this;
    }
  }, {
    key: "ldelim",
    value: function ldelim() {
      var head = this.head,
        tail = this.tail,
        len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
      }
      return this;
    }
  }, {
    key: "tag",
    value: function tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
  }, {
    key: "uint32",
    value: function uint32(value) {
      this.len += (this.tail = this.tail.next = new Op(_varint.writeVarint32, (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    }
  }, {
    key: "int32",
    value: function int32(value) {
      return value < 0 ? this._push(_varint.writeVarint64, 10, (0, _varint.int64FromString)(value.toString())) // 10 bytes per spec
      : this.uint32(value);
    }
  }, {
    key: "sint32",
    value: function sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }
  }, {
    key: "int64",
    value: function int64(value) {
      var _int64FromString = (0, _varint.int64FromString)(value.toString()),
        lo = _int64FromString.lo,
        hi = _int64FromString.hi;
      return this._push(_varint.writeVarint64, (0, _varint.int64Length)(lo, hi), {
        lo: lo,
        hi: hi
      });
    }
  }, {
    key: "sint64",
    value: function sint64(value) {
      var _int64FromString2 = (0, _varint.int64FromString)(value.toString()),
        lo = _int64FromString2.lo,
        hi = _int64FromString2.hi;
      // zig zag
      var _zzEncode = (0, _varint.zzEncode)(lo, hi);
      var _zzEncode2 = (0, _slicedToArray2["default"])(_zzEncode, 2);
      lo = _zzEncode2[0];
      hi = _zzEncode2[1];
      return this._push(_varint.writeVarint64, (0, _varint.int64Length)(lo, hi), {
        lo: lo,
        hi: hi
      });
    }
  }, {
    key: "fixed64",
    value: function fixed64(value) {
      var _int64FromString3 = (0, _varint.int64FromString)(value.toString()),
        lo = _int64FromString3.lo,
        hi = _int64FromString3.hi;
      return this._push(_varint.writeFixed32, 4, lo)._push(_varint.writeFixed32, 4, hi);
    }
  }, {
    key: "bool",
    value: function bool(value) {
      return this._push(_varint.writeByte, 1, value ? 1 : 0);
    }
  }, {
    key: "fixed32",
    value: function fixed32(value) {
      return this._push(_varint.writeFixed32, 4, value >>> 0);
    }
  }, {
    key: "float",
    value: function float(value) {
      throw new Error("float not supported" + value);
    }
  }, {
    key: "double",
    value: function double(value) {
      throw new Error("double not supported" + value);
    }
  }, {
    key: "bytes",
    value: function bytes(value) {
      var len = value.length >>> 0;
      if (!len) return this._push(_varint.writeByte, 1, 0);
      return this.uint32(len)._push(writeBytes, len, value);
    }
  }, {
    key: "string",
    value: function string(value) {
      var len = (0, _utf.utf8Length)(value);
      return len ? this.uint32(len)._push(_utf.utf8Write, len, value) : this._push(_varint.writeByte, 1, 0);
    }
  }], [{
    key: "create",
    value: function create() {
      return new BinaryWriter();
    }
  }, {
    key: "alloc",
    value: function alloc(size) {
      if (typeof Uint8Array !== "undefined") {
        return pool(function (size) {
          return new Uint8Array(size);
        }, Uint8Array.prototype.subarray)(size);
      } else {
        return new Array(size);
      }
    }
  }]);
  return BinaryWriter;
}();
exports.BinaryWriter = BinaryWriter;
function writeBytes(val, buf, pos) {
  if (typeof Uint8Array !== "undefined") {
    buf.set(val, pos);
  } else {
    for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i];
  }
}
function pool(alloc, slice, size) {
  var SIZE = size || 8192;
  var MAX = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size) {
    if (size < 1 || size > MAX) return alloc(size);
    if (offset + size > SIZE) {
      slab = alloc(SIZE);
      offset = 0;
    }
    var buf = slice.call(slab, offset, offset += size);
    if (offset & 7)
      // align to 32 bit
      offset = (offset | 7) + 1;
    return buf;
  };
}
function indexOutOfRange(reader, writeLength) {
  return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}